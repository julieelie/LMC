function [Voc_filename,Voc_samp_idx,Voc_transc_time] = voc_localize(Voc_dir,RawWav_dir, Date, ExpStartTime, varargin)
%% VOC_LOCALIZE a function to retrieve the position of manual extracts in continuous recordings
% Inputs
% Voc_dir is the folder containing the vocalization extracts to identify

% RawWav_dir is the folder containing the continuous recordings and the
% file *TTLPulseTimes.mat generated by align_soundmexAudio_2_logger.m
% in case calculating transceiver time is requested

% 'TransceiverTime' (optional input): set by default to 1 to calculate the
% onset anf offset of sound extracts in transceiver time

% Ouputs
% Voc_filename is the file list of manual extracts 

% Voc_samp_idx is a 2 column vector that gives the onset and offset indices
% of each extract in the original recordings, same number of lines as
% Voc_filename

% Voc_transc_time is a 2 column vector that gives the expected onset and offest
% times of each extract in the piezo logger recordings in transceiver time,
% in ms
% same number of lines as Voc_filename.

%% Load data and initialize output variables
% Get input arguments
Pnames = {'TransceiverTime', 'VocOperant'};
TranscTime = 1; % Logical to indicate if transceiver time should be calculated for these extracts.
VocOp = 0; % Logical to indicate if extract files were generated by vocOperant
Dflts  = {TranscTime VocOp};
[TranscTime, VocOp] = internal.stats.parseArgs(Pnames,Dflts,varargin{:});

if TranscTime
    % Load the pulse times and samples
    TTL_dir = dir(fullfile(RawWav_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
    TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));
end

% List of manual extracts
AllVocs = dir(fullfile(Voc_dir, sprintf('*%s*.wav', Date)));

% initialize variables
NVoc = length(AllVocs);
Voc_filename = cell(NVoc,1);
Voc_samp_idx = nan(NVoc,2);
Voc_transc_time = nan(NVoc,2);

%% Loop through extracts and localize them
for vv=1:NVoc
    fprintf('vocalization %d/%d\n',vv, NVoc);
    % load the extract
    Voc_filename{vv} = fullfile(AllVocs(vv).folder, AllVocs(vv).name);
    [Voc_wav] = audioread(Voc_filename{vv});
    
    % load the raw file
    Idx_ = strfind(AllVocs(vv).name, '_');
    if VocOp
        IdxSnip = strfind(AllVocs(vv).name, 'snipfile');
        Raw_filename = fullfile(RawWav_dir, [AllVocs(vv).name(1:(IdxSnip-1)) 'mic1' AllVocs(vv).name(IdxSnip+(8:10)) '.wav']);
    else
        Raw_filename = fullfile(RawWav_dir, [AllVocs(vv).name(1:(Idx_(end)-1)) '.wav']);
    end
    Raw_wav = audioread(Raw_filename);
    % Identify raw file index
    FileIdx = str2double(AllVocs(vv).name((Idx_(end-1)+1):(Idx_(end)-1)));
    
    
    % Find the localization of the extract in
    % the raw file
    Voc_samp_idx(vv,1) = strfind(Raw_wav', Voc_wav');
    Voc_samp_idx(vv,2) = Voc_samp_idx(vv,1) + length(Voc_wav);
     
    % if requested plot the result of the cross-crrelation
    Buffer = 1000;
    Raw_extract = Raw_wav((Voc_samp_idx(vv,1)-Buffer):(Voc_samp_idx(vv,2)+Buffer));
    plot(Raw_extract, 'k-', 'LineWidth',2);
    hold on
    plot(Buffer+(1:length(Voc_wav)), Voc_wav, 'r-')
    line([Buffer Buffer],[min(Voc_wav) max(Voc_wav)])
    hold off
    legend({'Raw recording', 'extract'})
    pause(1)
    
    if TranscTime
        % Extract the transceiver time 
        % zscore the sample stamps
        TTL_idx = find(unique(TTL.File_number) == FileIdx);
        Voc_samp_idx_zs = (Voc_samp_idx(vv,:) - TTL.Mean_std_Pulse_samp_audio(TTL_idx,1))/TTL.Mean_std_Pulse_samp_audio(TTL_idx,2);
        % calculate the transceiver times
        Voc_transc_time(vv,:) = TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2) .* polyval(TTL.Slope_and_intercept{TTL_idx},Voc_samp_idx_zs,[], TTL.Mean_std_x{TTL_idx}) + TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1);  
    end
end

%% save the calculation results
if TranscTime
    save(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx','Voc_transc_time')
else
    save(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx')
end
end

